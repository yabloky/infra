name: Mirror Container Images & Binaries

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Component name (folder with manifest.yaml)'
        required: true
        type: string

env:
  TARGET_NS: ghcr.io/${{ github.repository_owner }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq and yq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq grep
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load manifest
        id: manifest
        run: |
          MANIFEST="${{ github.event.inputs.component }}/manifest.yaml"
          [ ! -f "$MANIFEST" ] && echo "Manifest not found" && exit 1

          echo "type=$(yq '.type' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "source=$(yq '.source // ""' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "keep=$(yq '.keep_versions // 2' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "source_repo=$(yq '.source_repo // ""' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "asset_pattern=$(yq '.asset_pattern // ""' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "target_path=$(yq '.target_path // "."' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "tag_prefix=$(yq '.tag_prefix // ""' "$MANIFEST")" >> $GITHUB_OUTPUT
          
          # Ð§Ð¸Ñ‚Ð°ÐµÐ¼ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ñ‹Ð¹ Ñ‚ÐµÐ³. Ð•ÑÐ»Ð¸ Ð½ÐµÑ‚ - ÑÑ‚Ð°Ð²Ð¸Ð¼ latest
          echo "source_tag=$(yq '.source_tag // "latest"' "$MANIFEST")" >> $GITHUB_OUTPUT

          TARGET_OVERRIDE=$(yq '.target // ""' "$MANIFEST")
          if [ -n "$TARGET_OVERRIDE" ]; then
            echo "target=$TARGET_OVERRIDE" >> $GITHUB_OUTPUT
          else
            SOURCE=$(yq '.source // ""' "$MANIFEST")
            echo "target=${{ env.TARGET_NS }}/${SOURCE#*/}" >> $GITHUB_OUTPUT
          fi

      - name: Sync by type
        run: |
          TYPE="${{ steps.manifest.outputs.type }}"
          SOURCE="${{ steps.manifest.outputs.source }}"
          TARGET="${{ steps.manifest.outputs.target }}"
          KEEP="${{ steps.manifest.outputs.keep }}"
          SOURCE_REPO="${{ steps.manifest.outputs.source_repo }}"
          ASSET_PATTERN="${{ steps.manifest.outputs.asset_pattern }}"
          TAG_PREFIX="${{ steps.manifest.outputs.tag_prefix }}"
          SOURCE_TAG="${{ steps.manifest.outputs.source_tag }}"

          case "$TYPE" in
            container)
              echo "Syncing container: $SOURCE:$SOURCE_TAG â†’ $TARGET"
              
              # Ð’ÐÐ–ÐÐž: Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½ Ñ„Ð»Ð°Ð³ -L (sL) Ð´Ð»Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ñ€ÐµÐ´Ð¸Ñ€ÐµÐºÑ‚Ð° timberio -> vectordotdev
              RAW_TAG=$(curl -sL -H "Authorization: token ${GH_TOKEN}" "https://api.github.com/repos/${SOURCE_REPO}/releases/latest" | jq -r '.tag_name // empty')
              CLEAN_VERSION=$(echo "$RAW_TAG" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1)
              
              docker pull "$SOURCE:$SOURCE_TAG"
              UPSTREAM_ID=$(docker inspect --format='{{.Id}}' "$SOURCE:$SOURCE_TAG")
              
              LOCAL_LATEST_ID=""
              if docker pull "$TARGET:latest" > /dev/null 2>&1; then
                LOCAL_LATEST_ID=$(docker inspect --format='{{.Id}}' "$TARGET:latest")
              fi

              if [ "$LOCAL_LATEST_ID" == "$UPSTREAM_ID" ]; then
                echo "NO NEW VERSION: Image IDs match."; exit 0
              fi

              if docker image inspect "$TARGET:latest" >/dev/null 2>&1; then
                docker tag "$TARGET:latest" "$TARGET:back"
                docker push "$TARGET:back"
              fi

              if [ -n "$CLEAN_VERSION" ]; then
                docker tag "$SOURCE:$SOURCE_TAG" "$TARGET:$CLEAN_VERSION"
                docker push "$TARGET:$CLEAN_VERSION"
              fi
              
              docker tag "$SOURCE:$SOURCE_TAG" "$TARGET:latest"
              docker push "$TARGET:latest"

              ALL_VERSIONS=$(gh api -H "Accept: application/vnd.github+json" "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" | jq -r 'map(select(.metadata.container.tags | length > 0)) | sort_by(.created_at) | reverse | .[].metadata.container.tags[]?' | grep -vE 'latest|back' | uniq)
              COUNT=$(echo "$ALL_VERSIONS" | wc -l)
              if [ "$COUNT" -gt "$KEEP" ]; then
                TO_DELETE=$(echo "$ALL_VERSIONS" | tail -n +$((KEEP+1)))
                for T in $TO_DELETE; do
                  V_ID=$(gh api "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" | jq -r ".[] | select(.metadata.container.tags | index(\"$T\")) | .id")
                  gh api --method DELETE "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions/$V_ID"
                done
              fi
              ;;

            release-binary)
              echo "Syncing binary from: $SOURCE_REPO"
              REPO_FULL="${{ github.repository }}"
              
              # Normalize release name (e.g., 'netclient')
              DIST_TAG=$(echo "$TAG_PREFIX" | sed 's/-$//')
              [ -z "$DIST_TAG" ] && DIST_TAG="${SOURCE##*/}"

              # Fetch upstream info
              UPSTREAM_JSON=$(curl -sL -H "Authorization: token ${GH_TOKEN}" "https://api.github.com/repos/${SOURCE_REPO}/releases" | jq '.[0]')
              UPSTREAM_TAG=$(echo "$UPSTREAM_JSON" | jq -r '.tag_name // empty')
              
              ASSET_URL=$(echo "$UPSTREAM_JSON" | jq -r --arg pat "$ASSET_PATTERN" '(.assets // []) | .[] | select(.name | contains($pat)) | .browser_download_url' | head -n 1)
              
              if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" == "null" ]; then
                echo "Error: Asset matching '$ASSET_PATTERN' not found in $UPSTREAM_TAG"
                exit 1
              fi

              FILENAME=$(basename "$ASSET_URL")
              curl -L -s -o "/tmp/$FILENAME" "$ASSET_URL"
              UPSTREAM_HASH=$(sha256sum "/tmp/$FILENAME" | awk '{print $1}')

              # Check if distribution release exists
              if ! gh release view "$DIST_TAG" --repo "$REPO_FULL" >/dev/null 2>&1; then
                echo "Creating release: $DIST_TAG"
                gh release create "$DIST_TAG" --repo "$REPO_FULL" --title "$DIST_TAG" --notes "Tracking $SOURCE_REPO"
              fi

              # --- GET PREVIOUS VERSION INFO FROM DESCRIPTION ---
              OLD_NOTES=$(gh release view "$DIST_TAG" --repo "$REPO_FULL" --json body -q .body || echo "")
              # Regex adapted for new simple format: "ðŸŸ¢ Current: vX.X.X"
              PREV_VERSION_TAG=$(echo "$OLD_NOTES" | grep -oE 'Current: \S+' | awk '{print $2}' || echo "None")
              
              # Download current local 'latest' to check hash
              LOCAL_HASH=""
              mkdir -p /tmp/local
              if gh release download "$DIST_TAG" --repo "$REPO_FULL" -p "$FILENAME" -D "/tmp/local" >/dev/null 2>&1; then
                  LOCAL_HASH=$(sha256sum "/tmp/local/$FILENAME" | awk '{print $1}')
              fi

              if [ "$LOCAL_HASH" == "$UPSTREAM_HASH" ]; then
                echo "Up to date."
                exit 0
              fi

              echo "New version detected ($UPSTREAM_TAG). Updating..."

              # 1. MOVE OLD LATEST -> BACK (Overwrite existing back)
              if [ -n "$LOCAL_HASH" ]; then
                cp "/tmp/local/$FILENAME" "/tmp/${FILENAME}-back"
                gh release upload "$DIST_TAG" "/tmp/${FILENAME}-back" --repo "$REPO_FULL" --clobber
              fi
              
              # 2. UPLOAD NEW LATEST (Overwrite existing latest)
              gh release upload "$DIST_TAG" "/tmp/$FILENAME" --repo "$REPO_FULL" --clobber
              
              # 3. UPDATE DESCRIPTION (CLEAN UI)
              NEW_NOTES="ðŸŸ¢ Current: $UPSTREAM_TAG
              Hash: \`$UPSTREAM_HASH\`
              
              ðŸŸ  Previous: $PREV_VERSION_TAG
              (Renamed to: ${FILENAME}-back)
              
              _Updated: $(date)_"
              
              gh release edit "$DIST_TAG" --repo "$REPO_FULL" --notes "$NEW_NOTES"
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
