name: Mirror Container Images & Binaries

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Component name (e.g. nezha/nezha-agent)'
        required: true
        type: string

env:
  TARGET_NS: ghcr.io/${{ github.repository_owner }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq and yq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq grep
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load manifest
        id: manifest
        run: |
          MANIFEST="${{ github.event.inputs.component }}/manifest.yaml"
          if [ ! -f "$MANIFEST" ]; then
            echo "Manifest not found: $MANIFEST"
            exit 1
          fi

          TYPE=$(yq '.type' "$MANIFEST")
          SOURCE=$(yq '.source' "$MANIFEST")
          KEEP=$(yq '.keep_versions // 2' "$MANIFEST")
          SOURCE_REPO=$(yq '.source_repo // ""' "$MANIFEST")
          ASSET_PATTERN=$(yq '.asset_pattern // ""' "$MANIFEST")
          TARGET_PATH=$(yq '.target_path // "."' "$MANIFEST")
          TAG_PREFIX=$(yq '.tag_prefix // ""' "$MANIFEST")

          TARGET_OVERRIDE=$(yq '.target // ""' "$MANIFEST")
          if [ -n "$TARGET_OVERRIDE" ]; then
            TARGET="$TARGET_OVERRIDE"
          else
            if [[ "$SOURCE" == */* ]]; then
              IMAGE_NAME="${SOURCE#*/}"
            else
              IMAGE_NAME="$SOURCE"
            fi
            TARGET="${{ env.TARGET_NS }}/$IMAGE_NAME"
          fi

          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "source=$SOURCE" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "keep=$KEEP" >> $GITHUB_OUTPUT
          echo "source_repo=$SOURCE_REPO" >> $GITHUB_OUTPUT
          echo "asset_pattern=$ASSET_PATTERN" >> $GITHUB_OUTPUT
          echo "target_path=$TARGET_PATH" >> $GITHUB_OUTPUT
          echo "tag_prefix=$TAG_PREFIX" >> $GITHUB_OUTPUT

      - name: Sync by type
        run: |
          TYPE="${{ steps.manifest.outputs.type }}"
          SOURCE="${{ steps.manifest.outputs.source }}"
          TARGET="${{ steps.manifest.outputs.target }}"
          KEEP="${{ steps.manifest.outputs.keep }}"
          SOURCE_REPO="${{ steps.manifest.outputs.source_repo }}"
          ASSET_PATTERN="${{ steps.manifest.outputs.asset_pattern }}"
          TARGET_PATH="${{ steps.manifest.outputs.target_path }}"
          TAG_PREFIX="${{ steps.manifest.outputs.tag_prefix }}"

          mkdir -p "$TARGET_PATH"

          # --- COMMON VERSION DETERMINATION START ---
          
          if [ -z "$SOURCE_REPO" ]; then
            echo "Error: SOURCE_REPO must be specified for version tracking."
            exit 1
          fi
          
          # Filter for the highest numbered release that does NOT contain instability suffixes.
          STABLE_RELEASE_FILTER='
            .[] 
            | select(.prerelease == false) 
            | .tag_name 
            | select(
                (test("-(alpha|beta|rc|dev|test|snapshot)"; "i") | not) and
                (test("[0-9]+(\\.[0-9]+)+$"))
              ) // empty
            '
            
          # Get the highest STABLE version tag from GitHub Releases (Priority 1: ONLY GITHUB)
          UPSTREAM_TAG=$(curl -s "https://api.github.com/repos/${SOURCE_REPO}/releases" \
            | jq -r "$STABLE_RELEASE_FILTER" \
            | sort -Vr \
            | head -n 1)

          # CRITICAL CHECK: No Fallback to Docker Hub is allowed.
          if [ -z "$UPSTREAM_TAG" ]; then
            echo "Error: Could not find any stable release in GitHub Releases (${SOURCE_REPO}). Aborting."
            exit 1
          fi
          
          # Clean the tag: Remove any non-digit/non-dot/non-hyphen characters before the first digit.
          # This converts 'n8n@1.123.4' to '1.123.4' and 'v1.2.3' to '1.2.3'
          CLEAN_TAG=$(echo "$UPSTREAM_TAG" | sed 's/^[^0-9]*//' | sed 's/[^0-9\.\-].*$//')
          
          if [ -n "$CLEAN_TAG" ]; then
            UPSTREAM_TAG="$CLEAN_TAG"
          else
            echo "Warning: Failed to clean UPSTREAM_TAG '$UPSTREAM_TAG'. Using original."
          fi
          
          # --- COMMON VERSION DETERMINATION END ---

          case "$TYPE" in
            container)
              echo "Syncing container: $SOURCE → $TARGET"

              SOURCE_IMAGE="$SOURCE:latest"
              TARGET_IMAGE="$TARGET"
              TARGET_TAG="$UPSTREAM_TAG"
              
              # 1. Pull the 'latest' image (assuming author updates latest to match UPSTREAM_TAG)
              if ! docker pull "$SOURCE_IMAGE"; then
                echo "Error: Failed to pull $SOURCE_IMAGE. Aborting container sync."
                exit 1
              fi

              LATEST_ID=$(docker inspect --format='{{.Id}}' "$SOURCE_IMAGE")
              echo "Upstream 'latest' Image ID: $LATEST_ID"
              echo "Targeting stable version tag: $TARGET_TAG"

              LOCAL_TAG_ID=""
              
              if docker pull "$TARGET_IMAGE:$TARGET_TAG" > /dev/null 2>&1; then
                LOCAL_TAG_ID=$(docker inspect --format='{{.Id}}' "$TARGET_IMAGE:$TARGET_TAG")
                docker rmi "$TARGET_IMAGE:$TARGET_TAG"
              fi

              if [ -n "$LOCAL_TAG_ID" ] && [ "$LOCAL_TAG_ID" == "$LATEST_ID" ]; then
                echo "SKIP: Version tag $TARGET_TAG already points to the same content ($LOCAL_TAG_ID). No push needed."
              else
                # 3. Publish the new version
                echo "NEW VERSION DETECTED. Pushing $TARGET_TAG..."
                docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE:$TARGET_TAG"
                docker push "$TARGET_IMAGE:$TARGET_TAG"
              fi
              
              # 4. Ensure 'latest' always points to the newest published image ID
              echo "Ensuring 'latest' tag points to $LATEST_ID."
              docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE:latest"
              docker push "$TARGET_IMAGE:latest"

              # 5. Cleanup Logic (to remove old versions based on KEEP)
              
              ALL_VERSIONS_DATA=$(gh api -H "Accept: application/vnd.github+json" \
                "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" \
                2>/dev/null)

              if [ -z "$ALL_VERSIONS_DATA" ]; then
                  echo "No versions found in registry for cleanup."
                  break
              fi

              # Extract all numeric/version tags (excluding 'latest') and sort them by version string, reverse
              ALL_TAGS=$(echo "$ALL_VERSIONS_DATA" \
                | jq -r '
                    map(select(.metadata.container.tags and (.metadata.container.tags | length > 0))) 
                    | sort_by(.created_at) 
                    | reverse 
                    | .[].metadata.container.tags[]?
                  ' \
                | grep -v '^$' | grep -v '^latest$' | sort -Vr)
              
              COUNT=$(echo "$ALL_TAGS" | wc -l)
              
              if [ "$COUNT" -gt "$KEEP" ]; then
                echo "Cleanup required: $COUNT version tags found, keeping $KEEP."
                TO_DELETE_TAGS=$(echo "$ALL_TAGS" | tail -n +$((KEEP+1)))
                
                while IFS= read -r TAG_DEL; do
                  if [ -z "$TAG_DEL" ]; then continue; fi
                  
                  # Find the unique ID associated with the specific tag
                  VERSION_ID=$(echo "$ALL_VERSIONS_DATA" \
                    | jq -r ".[] | select(.metadata.container.tags and (.metadata.container.tags | index(\"$TAG_DEL\"))) | .id")

                  if [ -n "$VERSION_ID" ]; then
                    echo "Deleting old version tag: $TAG_DEL (ID: $VERSION_ID)"
                    # Note: We can only delete the entire version ID, not just a tag.
                    gh api --method DELETE "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions/$VERSION_ID"
                  else
                      echo "Warning: Could not find Version ID for tag $TAG_DEL."
                  fi
                done <<< "$TO_DELETE_TAGS"
              fi
              ;;

            release-binary)
              echo "Syncing binary from GitHub Releases: $SOURCE_REPO"
              
              # UPSTREAM_TAG already determined by COMMON VERSION DETERMINATION
              
              if [ -z "$ASSET_PATTERN" ]; then
                echo "Missing asset_pattern"
                exit 1
              fi

              # Check if the desired tag already exists in our repo (gh releases)
              TAG_LATEST="${TAG_PREFIX}latest"
              TAG_VERSION="${TAG_PREFIX}${UPSTREAM_TAG}"
              
              CURRENT_VERSION_IN_REPO=""

              # 1. Download asset URL
              # Note: UPSTREAM_TAG is calculated globally using STABLE_VERSION_FILTER
              ASSET_URL=$(curl -s "https://api.github.com/repos/${SOURCE_REPO}/releases/tags/${UPSTREAM_TAG}" | jq -r --arg pat "$ASSET_PATTERN" '.assets[] | select(.name | endswith($pat)) | .browser_download_url')
              if [ -z "$ASSET_URL" ]; then
                echo "Asset not found for $UPSTREAM_TAG"
                exit 1
              fi

              FILENAME=$(basename "$ASSET_URL")
              TMP_FILE="/tmp/$FILENAME"
              REPO_FULL="${{ github.repository }}"
              
              # Check if the asset exists for the current UPSTREAM_TAG locally tagged as TAG_LATEST
              if gh release view "$TAG_LATEST" --repo "$REPO_FULL" >/dev/null 2>&1; then
                 # Extract version from existing release body (Version: X.Y.Z)
                CURRENT_VERSION_IN_REPO=$(gh release view "$TAG_LATEST" --repo "$REPO_FULL" --json body -q '.body' 2>/dev/null | grep -o 'Version: [^ ]*' | cut -d' ' -f2)
              fi
              
              if [ "$CURRENT_VERSION_IN_REPO" == "$UPSTREAM_TAG" ]; then
                echo "SKIP: Binary version $UPSTREAM_TAG already exists and is marked as $TAG_LATEST."
              else
                # 2. Archive the previous TAG_LATEST (if it existed)
                if [ -n "$CURRENT_VERSION_IN_REPO" ]; then
                  ARCHIVE_TAG="${TAG_PREFIX}${CURRENT_VERSION_IN_REPO#v}"
                  
                  echo "Archiving old version: $CURRENT_VERSION_IN_REPO → $ARCHIVE_TAG"
                  
                  # Delete old releases that are not the current version or the archive version (Cleanup)
                  ALL_TAGS=$(gh api "repos/$REPO_FULL/releases" --jq '.[].tag_name' 2>/dev/null)
                  echo "$ALL_TAGS" | while IFS= read -r T; do
                    if [ -n "$T" ] && [ "$T" != "$TAG_LATEST" ] && [ "$T" != "$ARCHIVE_TAG" ]; then
                      echo "Deleting obsolete release: $T"
                      gh release delete "$T" --repo "$REPO_FULL" --yes
                    fi
                  done
                  
                  # Download the old binary before deleting TAG_LATEST
                  gh release download "$TAG_LATEST" --repo "$REPO_FULL" -p "$FILENAME" -D "/tmp"
                  
                  # Delete old TAG_LATEST
                  gh release delete "$TAG_LATEST" --repo "$REPO_FULL" --yes

                  # Create archive tag
                  gh release create "$ARCHIVE_TAG" "/tmp/$FILENAME" \
                    --repo "$REPO_FULL" \
                    --title "$ARCHIVE_TAG" \
                    --notes "Archived version $CURRENT_VERSION_IN_REPO"
                fi

                # 3. Download the new asset and publish it as TAG_LATEST
                echo "Downloading new version $UPSTREAM_TAG..."
                curl -L -o "$TMP_FILE" "$ASSET_URL"

                gh release create "$TAG_LATEST" "$TMP_FILE" \
                  --repo "$REPO_FULL" \
                  --title "$TAG_LATEST" \
                  --notes "Version: $UPSTREAM_TAG\nMirrored from https://github.com/${SOURCE_REPO}"
                
                rm -f "$TMP_FILE"
              fi
              
              echo "Done. Current binary release is $TAG_LATEST (Version: $UPSTREAM_TAG)."
              ;;

            *)
              echo "Unknown type: $TYPE"
              exit 1
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
