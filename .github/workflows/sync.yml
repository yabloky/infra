name: Mirror Container Images & Binaries

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Component name (e.g. komodo)'
        required: true
        type: string

env:
  TARGET_NS: ghcr.io/${{ github.repository_owner }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq and yq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load manifest
        id: manifest
        run: |
          MANIFEST="${{ github.event.inputs.component }}/manifest.yaml"
          if [ ! -f "$MANIFEST" ]; then
            echo "Manifest not found: $MANIFEST"
            exit 1
          fi

          TYPE=$(yq '.type' "$MANIFEST")
          SOURCE=$(yq '.source' "$MANIFEST")
          KEEP=$(yq '.keep_versions // 2' "$MANIFEST")
          SOURCE_REPO=$(yq '.source_repo // ""' "$MANIFEST")
          ASSET_PATTERN=$(yq '.asset_pattern // ""' "$MANIFEST")
          TARGET_PATH=$(yq '.target_path // "binaries/"' "$MANIFEST")

          # Handle target: if not set, build from source
          TARGET_OVERRIDE=$(yq '.target // ""' "$MANIFEST")
          if [ -n "$TARGET_OVERRIDE" ]; then
            TARGET="$TARGET_OVERRIDE"
          else
            # Strip original registry, keep image name
            if [[ "$SOURCE" == */* ]]; then
              IMAGE_NAME="${SOURCE#*/}"
            else
              IMAGE_NAME="$SOURCE"
            fi
            TARGET="${{ env.TARGET_NS }}/$IMAGE_NAME"
          fi

          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "source=$SOURCE" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "keep=$KEEP" >> $GITHUB_OUTPUT
          echo "source_repo=$SOURCE_REPO" >> $GITHUB_OUTPUT
          echo "asset_pattern=$ASSET_PATTERN" >> $GITHUB_OUTPUT
          echo "target_path=$TARGET_PATH" >> $GITHUB_OUTPUT

      - name: Sync by type
        run: |
          TYPE="${{ steps.manifest.outputs.type }}"
          SOURCE="${{ steps.manifest.outputs.source }}"
          TARGET="${{ steps.manifest.outputs.target }}"
          KEEP="${{ steps.manifest.outputs.keep }}"
          SOURCE_REPO="${{ steps.manifest.outputs.source_repo }}"
          ASSET_PATTERN="${{ steps.manifest.outputs.asset_pattern }}"
          TARGET_PATH="${{ steps.manifest.outputs.target_path }}"

          case "$TYPE" in
            container)
              echo "Syncing container: $SOURCE → $TARGET"

              # Detect source: GHCR or Docker Hub
              if [[ "$SOURCE" == ghcr.io/* ]]; then
                REPO="${SOURCE#ghcr.io/}"
              elif [[ "$SOURCE" == docker.io/* ]]; then
                REPO="${SOURCE#docker.io/}"
                REPO="${REPO#library/}"
              else
                REPO="$SOURCE"
              fi

              TAGS=$(curl -s "https://hub.docker.com/v2/repositories/${REPO}/tags/?page_size=100" \
                | jq -r '.results[].name' | \
                grep -E '^[vV]?[0-9]+(\.[0-9]+)*$' | \
                grep -v -E '[a-zA-Z]' | sort -Vr)

              if [ -z "$TAGS" ]; then
                echo "No tags found in source"
                exit 1
              fi

              echo "Available source tags:"
              echo "$TAGS"

              # Get local tags — safely
              LOCAL_TAGS=""
              if gh api -H "Accept: application/vnd.github+json" \
                "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" >/dev/null 2>&1; then
                LOCAL_TAGS=$(gh api -H "Accept: application/vnd.github+json" \
                  "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" \
                  | jq -r '.[].metadata.container.tags[]? // empty' | grep -v '^$' | sort -Vr)
              fi

              echo "Existing local tags:"
              if [ -z "$LOCAL_TAGS" ]; then
                echo "(none)"
              else
                echo "$LOCAL_TAGS"
              fi

              # Take first N tags
              NEW_TAGS=$(echo "$TAGS" | head -n "$KEEP")

              # Pull and push new ones
              while IFS= read -r TAG; do
                if [ -z "$TAG" ]; then continue; fi
                if echo "$LOCAL_TAGS" | grep -Fxq "$TAG"; then
                  echo "Already have $TAG — skip"
                  continue
                fi
                echo "Pulling $SOURCE:$TAG"
                docker pull "$SOURCE:$TAG"
                docker tag "$SOURCE:$TAG" "$TARGET:$TAG"
                docker push "$TARGET:$TAG"
              done <<< "$NEW_TAGS"

              # Delete old versions — safely
              ALL_LOCAL=""
              if gh api -H "Accept: application/vnd.github+json" \
                "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" >/dev/null 2>&1; then
                ALL_LOCAL=$(gh api -H "Accept: application/vnd.github+json" \
                  "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" \
                  | jq -r 'map(select(.metadata.container.tags and (.metadata.container.tags | length > 0))) | sort_by(.created_at) | reverse | .[].metadata.container.tags[]?' \
                  | grep -v '^$' | sort -Vr)
              fi

              COUNT=$(echo "$ALL_LOCAL" | wc -l)
              if [ "$COUNT" -gt "$KEEP" ]; then
                TO_DELETE=$(echo "$ALL_LOCAL" | tail -n +$((KEEP+1)))
                while IFS= read -r TAG_DEL; do
                  if [ -z "$TAG_DEL" ]; then continue; fi
                  ID=$(gh api -H "Accept: application/vnd.github+json" \
                    "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" \
                    | jq -r ".[] | select(.metadata.container.tags and (.metadata.container.tags | index(\"$TAG_DEL\"))) | .id")
                  if [ -n "$ID" ]; then
                    echo "Deleting old version: $TAG_DEL (ID: $ID)"
                    gh api --method DELETE "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions/$ID"
                  fi
                done <<< "$TO_DELETE"
              fi

              # Update latest tag
              LATEST=$(echo "$NEW_TAGS" | head -n1)
              if [ -n "$LATEST" ]; then
                echo "Updating 'latest' tag to $LATEST"
                docker pull "$SOURCE:$LATEST"
                docker tag "$SOURCE:$LATEST" "$TARGET:latest"
                docker push "$TARGET:latest"
              fi
              ;;

            release-binary)
              echo "Syncing binary from GitHub Releases: $SOURCE_REPO"
              if [ -z "$SOURCE_REPO" ] || [ -z "$ASSET_PATTERN" ]; then
                echo "Missing source_repo or asset_pattern"
                exit 1
              fi

              mkdir -p "$TARGET_PATH"

              # Fetch latest release
              RELEASE=$(curl -s "https://api.github.com/repos/$SOURCE_REPO/releases/latest")
              VERSION=$(echo "$RELEASE" | jq -r '.tag_name')
              ASSET_URL=$(echo "$RELEASE" | jq -r ".assets[] | select(.name | test(\"$ASSET_PATTERN\")) | .browser_download_url")

              if [ -z "$ASSET_URL" ]; then
                echo "Asset matching pattern '$ASSET_PATTERN' not found"
                exit 1
              fi

              FILENAME=$(basename "$ASSET_URL")
              DEST="$TARGET_PATH/$FILENAME"

              echo "Downloading $FILENAME from $ASSET_URL"
              curl -L -o "$DEST" "$ASSET_URL"

              # Clean old versions
              cd "$TARGET_PATH"
              FILES=$(ls -t | grep -E "^$(echo "$FILENAME" | sed 's/\..*$//')")
              COUNT=$(echo "$FILES" | wc -l)
              if [ "$COUNT" -gt "$KEEP" ]; then
                TO_DELETE=$(echo "$FILES" | tail -n +$((KEEP+1)))
                for F in $TO_DELETE; do
                  echo "Deleting old binary: $F"
                  rm -f "$F"
                done
              fi

              # Create latest symlink
              LATEST_FILE="$(echo "$FILENAME" | sed 's/\..*$//')-latest$(echo "$FILENAME" | sed 's/.*\(\..*\)/\1/')"
              ln -sf "$FILENAME" "$LATEST_FILE"

              echo "Done. Binary saved as $DEST"
              ;;

            *)
              echo "Unknown type: $TYPE"
              exit 1
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
