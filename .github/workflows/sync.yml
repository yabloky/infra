name: Mirror Container Images & Binaries

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Component name (e.g. nezha/nezha-agent)'
        required: true
        type: string

env:
  TARGET_NS: ghcr.io/${{ github.repository_owner }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write  # Required to push GitHub Releases
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq and yq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load manifest
        id: manifest
        run: |
          MANIFEST="${{ github.event.inputs.component }}/manifest.yaml"
          if [ ! -f "$MANIFEST" ]; then
            echo "Manifest not found: $MANIFEST"
            exit 1
          fi

          TYPE=$(yq '.type' "$MANIFEST")
          SOURCE=$(yq '.source' "$MANIFEST")
          KEEP=$(yq '.keep_versions // 2' "$MANIFEST")
          SOURCE_REPO=$(yq '.source_repo // ""' "$MANIFEST")
          ASSET_PATTERN=$(yq '.asset_pattern // ""' "$MANIFEST")
          TARGET_PATH=$(yq '.target_path // "."' "$MANIFEST")
          TAG_PREFIX=$(yq '.tag_prefix // ""' "$MANIFEST")

          TARGET_OVERRIDE=$(yq '.target // ""' "$MANIFEST")
          if [ -n "$TARGET_OVERRIDE" ]; then
            TARGET="$TARGET_OVERRIDE"
          else
            if [[ "$SOURCE" == */* ]]; then
              IMAGE_NAME="${SOURCE#*/}"
            else
              IMAGE_NAME="$SOURCE"
            fi
            TARGET="${{ env.TARGET_NS }}/$IMAGE_NAME"
          fi

          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "source=$SOURCE" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "keep=$KEEP" >> $GITHUB_OUTPUT
          echo "source_repo=$SOURCE_REPO" >> $GITHUB_OUTPUT
          echo "asset_pattern=$ASSET_PATTERN" >> $GITHUB_OUTPUT
          echo "target_path=$TARGET_PATH" >> $GITHUB_OUTPUT
          echo "tag_prefix=$TAG_PREFIX" >> $GITHUB_OUTPUT

      - name: Sync by type
        run: |
          TYPE="${{ steps.manifest.outputs.type }}"
          SOURCE="${{ steps.manifest.outputs.source }}"
          TARGET="${{ steps.manifest.outputs.target }}"
          KEEP="${{ steps.manifest.outputs.keep }}"
          SOURCE_REPO="${{ steps.manifest.outputs.source_repo }}"
          ASSET_PATTERN="${{ steps.manifest.outputs.asset_pattern }}"
          TARGET_PATH="${{ steps.manifest.outputs.target_path }}"
          TAG_PREFIX="${{ steps.manifest.outputs.tag_prefix }}"

          mkdir -p "$TARGET_PATH"

          case "$TYPE" in
            container)
              echo "Syncing container: $SOURCE → $TARGET"

              if [ -n "$SOURCE_REPO" ]; then
                TAGS=$(curl -s "https://api.github.com/repos/${SOURCE_REPO}/releases" \
                  | jq -r '.[] | select(.prerelease == false) | .tag_name' \
                  | grep -E '^v?[0-9]+(\.[0-9]+)*$' \
                  | sort -Vr)
              else
                if [[ "$SOURCE" == ghcr.io/* ]]; then
                  REPO="${SOURCE#ghcr.io/}"
                elif [[ "$SOURCE" == docker.io/* ]]; then
                  REPO="${SOURCE#docker.io/}"
                  REPO="${REPO#library/}"
                else
                  REPO="$SOURCE"
                fi
                TAGS=$(curl -s "https://hub.docker.com/v2/repositories/${REPO}/tags/?page_size=100" \
                  | jq -r '.results[].name' \
                  | grep -E '^v?[0-9]+(\.[0-9]+)*$' \
                  | sort -Vr)
              fi

              if [ -z "$TAGS" ]; then
                echo "No tags found in source"
                exit 1
              fi

              echo "Available source tags:"
              echo "$TAGS"

              LOCAL_TAGS=""
              if gh api -H "Accept: application/vnd.github+json" \
                "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" >/dev/null 2>&1; then
                LOCAL_TAGS=$(gh api -H "Accept: application/vnd.github+json" \
                  "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" \
                  | jq -r '.[].metadata.container.tags[]? // empty' | grep -v '^$' | sort -Vr)
              fi

              echo "Existing local tags:"
              if [ -z "$LOCAL_TAGS" ]; then
                echo "(none)"
              else
                echo "$LOCAL_TAGS"
              fi

              NEW_TAGS=$(echo "$TAGS" | head -n "$KEEP")

              while IFS= read -r TAG; do
                if [ -z "$TAG" ]; then continue; fi
                if echo "$LOCAL_TAGS" | grep -Fxq "$TAG"; then
                  echo "Already have $TAG — skip"
                  continue
                fi
                echo "Pulling $SOURCE:$TAG"
                if docker pull "$SOURCE:$TAG"; then
                  docker tag "$SOURCE:$TAG" "$TARGET:$TAG"
                  docker push "$TARGET:$TAG"
                else
                  echo "Failed to pull $SOURCE:$TAG — skipping"
                fi
              done <<< "$NEW_TAGS"

              ALL_LOCAL=""
              if gh api -H "Accept: application/vnd.github+json" \
                "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" >/dev/null 2>&1; then
                ALL_LOCAL=$(gh api -H "Accept: application/vnd.github+json" \
                  "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" \
                  | jq -r 'map(select(.metadata.container.tags and (.metadata.container.tags | length > 0))) | sort_by(.created_at) | reverse | .[].metadata.container.tags[]?' \
                  | grep -v '^$' | sort -Vr)
              fi

              COUNT=$(echo "$ALL_LOCAL" | wc -l)
              if [ "$COUNT" -gt "$KEEP" ]; then
                TO_DELETE=$(echo "$ALL_LOCAL" | tail -n +$((KEEP+1)))
                while IFS= read -r TAG_DEL; do
                  if [ -z "$TAG_DEL" ]; then continue; fi
                  ID=$(gh api -H "Accept: application/vnd.github+json" \
                    "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" \
                    | jq -r ".[] | select(.metadata.container.tags and (.metadata.container.tags | index(\"$TAG_DEL\"))) | .id")
                  if [ -n "$ID" ]; then
                    echo "Deleting old version: $TAG_DEL (ID: $ID)"
                    gh api --method DELETE "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions/$ID"
                  fi
                done <<< "$TO_DELETE"
              fi

              LATEST=$(echo "$TAGS" | head -n1)
              if [ -n "$LATEST" ]; then
                echo "Updating 'latest' tag to $LATEST"
                if docker pull "$SOURCE:$LATEST"; then
                  docker tag "$SOURCE:$LATEST" "$TARGET:latest"
                  docker push "$TARGET:latest"
                fi
              fi
              ;;

            release-binary)
              echo "Syncing binary from GitHub Releases: $SOURCE_REPO"
              if [ -z "$SOURCE_REPO" ] || [ -z "$ASSET_PATTERN" ]; then
                echo "Missing source_repo or asset_pattern"
                exit 1
              fi

              # Fetch ALL stable releases (not just 'latest')
              ALL_RELEASES=$(curl -s "https://api.github.com/repos/${SOURCE_REPO}/releases" | jq -r --arg pat "$ASSET_PATTERN" '
                .[] |
                select(.prerelease == false) |
                select(.assets | map(select(.name | endswith($pat))) | length > 0) |
                .tag_name
              ' | sort -Vr)

              if [ -z "$ALL_RELEASES" ]; then
                echo "No matching stable releases found for pattern '$ASSET_PATTERN'"
                exit 1
              fi

              echo "Found upstream releases:"
              echo "$ALL_RELEASES"

              # Keep only the required number of versions
              NEW_RELEASES=$(echo "$ALL_RELEASES" | head -n "$KEEP")

              REPO_FULL="${{ github.repository }}"
              PREFIX="$TAG_PREFIX"

              # Get ALL existing releases in YOUR repo, filtered by prefix
              ALL_LOCAL_TAGS=$(gh api "repos/$REPO_FULL/releases" --jq 'sort_by(.created_at) | reverse | .[].tag_name' 2>/dev/null)
              if [ -n "$PREFIX" ]; then
                LOCAL_TAGS=$(echo "$ALL_LOCAL_TAGS" | grep "^$PREFIX" || true)
              else
                LOCAL_TAGS="$ALL_LOCAL_TAGS"
              fi

              echo "Existing local releases (with prefix '$PREFIX'):"
              if [ -z "$LOCAL_TAGS" ]; then
                echo "(none)"
              else
                echo "$LOCAL_TAGS"
              fi

              # Download and publish each required version
              while IFS= read -r VERSION; do
                if [ -z "$VERSION" ]; then continue; fi

                # Build local release tag with prefix
                if [ -n "$PREFIX" ]; then
                  LOCAL_TAG="${PREFIX}${VERSION}"
                else
                  LOCAL_TAG="$VERSION"
                fi

                # Skip if already exists
                if echo "$LOCAL_TAGS" | grep -Fxq "$LOCAL_TAG"; then
                  echo "Release $LOCAL_TAG already exists — skip"
                  continue
                fi

                # Get asset URL for this version
                ASSET_URL=$(curl -s "https://api.github.com/repos/${SOURCE_REPO}/releases/tags/${VERSION}" | jq -r --arg pat "$ASSET_PATTERN" '.assets[] | select(.name | endswith($pat)) | .browser_download_url')
                if [ -z "$ASSET_URL" ]; then
                  echo "Asset for $VERSION not found — skip"
                  continue
                fi

                FILENAME=$(basename "$ASSET_URL")
                TMP_FILE="/tmp/$FILENAME"
                curl -L -o "$TMP_FILE" "$ASSET_URL"

                echo "Creating release: $LOCAL_TAG"
                gh release create "$LOCAL_TAG" "$TMP_FILE" \
                  --repo "$REPO_FULL" \
                  --title "$LOCAL_TAG" \
                  --notes "Mirrored from https://github.com/${SOURCE_REPO}/releases/tag/${VERSION}"

                rm -f "$TMP_FILE"
              done <<< "$NEW_RELEASES"

              # Delete old releases if count exceeds keep_versions
              if [ -n "$LOCAL_TAGS" ]; then
                CURRENT_COUNT=$(echo "$LOCAL_TAGS" | wc -l)
                if [ "$CURRENT_COUNT" -gt "$KEEP" ]; then
                  # Refresh list after potential new releases
                  ALL_LOCAL_TAGS=$(gh api "repos/$REPO_FULL/releases" --jq 'sort_by(.created_at) | reverse | .[].tag_name' 2>/dev/null)
                  if [ -n "$PREFIX" ]; then
                    LOCAL_TAGS=$(echo "$ALL_LOCAL_TAGS" | grep "^$PREFIX" | head -n "$CURRENT_COUNT")
                  else
                    LOCAL_TAGS=$(echo "$ALL_LOCAL_TAGS" | head -n "$CURRENT_COUNT")
                  fi

                  TO_DELETE=$(echo "$LOCAL_TAGS" | tail -n +$((KEEP+1)))
                  while IFS= read -r OLD_TAG; do
                    if [ -n "$OLD_TAG" ]; then
                      echo "Deleting old release: $OLD_TAG"
                      gh release delete "$OLD_TAG" --repo "$REPO_FULL" --yes
                    fi
                  done <<< "$TO_DELETE"
                fi
              fi

              echo "Done. Binary releases synchronized."
              ;;

            *)
              echo "Unknown type: $TYPE"
              exit 1
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
