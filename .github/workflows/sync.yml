name: Mirror Container Images & Binaries

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Component name (folder with manifest.yaml)'
        required: true
        type: string

env:
  TARGET_NS: ghcr.io/${{ github.repository_owner }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq and yq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq grep
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load manifest
        id: manifest
        run: |
          MANIFEST="${{ github.event.inputs.component }}/manifest.yaml"
          [ ! -f "$MANIFEST" ] && echo "Manifest not found" && exit 1

          echo "type=$(yq '.type' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "source=$(yq '.source // ""' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "keep=$(yq '.keep_versions // 2' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "source_repo=$(yq '.source_repo // ""' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "asset_pattern=$(yq '.asset_pattern // ""' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "target_path=$(yq '.target_path // "."' "$MANIFEST")" >> $GITHUB_OUTPUT
          echo "tag_prefix=$(yq '.tag_prefix // ""' "$MANIFEST")" >> $GITHUB_OUTPUT

          TARGET_OVERRIDE=$(yq '.target // ""' "$MANIFEST")
          if [ -n "$TARGET_OVERRIDE" ]; then
            echo "target=$TARGET_OVERRIDE" >> $GITHUB_OUTPUT
          else
            SOURCE=$(yq '.source // ""' "$MANIFEST")
            echo "target=${{ env.TARGET_NS }}/${SOURCE#*/}" >> $GITHUB_OUTPUT
          fi

      - name: Sync by type
        run: |
          TYPE="${{ steps.manifest.outputs.type }}"
          SOURCE="${{ steps.manifest.outputs.source }}"
          TARGET="${{ steps.manifest.outputs.target }}"
          KEEP="${{ steps.manifest.outputs.keep }}"
          SOURCE_REPO="${{ steps.manifest.outputs.source_repo }}"
          ASSET_PATTERN="${{ steps.manifest.outputs.asset_pattern }}"
          TAG_PREFIX="${{ steps.manifest.outputs.tag_prefix }}"

          case "$TYPE" in
            container)
              echo "Syncing container: $SOURCE â†’ $TARGET"
              RAW_TAG=$(curl -s -H "Authorization: token ${GH_TOKEN}" "https://api.github.com/repos/${SOURCE_REPO}/releases/latest" | jq -r '.tag_name // empty')
              CLEAN_VERSION=$(echo "$RAW_TAG" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1)
              
              docker pull "$SOURCE:latest"
              UPSTREAM_ID=$(docker inspect --format='{{.Id}}' "$SOURCE:latest")
              
              LOCAL_LATEST_ID=""
              if docker pull "$TARGET:latest" > /dev/null 2>&1; then
                LOCAL_LATEST_ID=$(docker inspect --format='{{.Id}}' "$TARGET:latest")
              fi

              if [ "$LOCAL_LATEST_ID" == "$UPSTREAM_ID" ]; then
                echo "NO NEW VERSION: Image IDs match."; exit 0
              fi

              if docker image inspect "$TARGET:latest" >/dev/null 2>&1; then
                docker tag "$TARGET:latest" "$TARGET:back"
                docker push "$TARGET:back"
              fi

              if [ -n "$CLEAN_VERSION" ]; then
                docker tag "$SOURCE:latest" "$TARGET:$CLEAN_VERSION"
                docker push "$TARGET:$CLEAN_VERSION"
              fi
              
              docker tag "$SOURCE:latest" "$TARGET:latest"
              docker push "$TARGET:latest"

              ALL_VERSIONS=$(gh api -H "Accept: application/vnd.github+json" "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" | jq -r 'map(select(.metadata.container.tags | length > 0)) | sort_by(.created_at) | reverse | .[].metadata.container.tags[]?' | grep -vE 'latest|back' | uniq)
              COUNT=$(echo "$ALL_VERSIONS" | wc -l)
              if [ "$COUNT" -gt "$KEEP" ]; then
                TO_DELETE=$(echo "$ALL_VERSIONS" | tail -n +$((KEEP+1)))
                for T in $TO_DELETE; do
                  V_ID=$(gh api "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" | jq -r ".[] | select(.metadata.container.tags | index(\"$T\")) | .id")
                  gh api --method DELETE "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions/$V_ID"
                done
              fi
              ;;

            release-binary)
              echo "Syncing binary: $SOURCE_REPO"
              REPO_FULL="${{ github.repository }}"
              TAG_LATEST="${TAG_PREFIX}latest"
              TAG_BACK="${TAG_PREFIX}back"

              UPSTREAM_JSON=$(curl -s -H "Authorization: token ${GH_TOKEN}" "https://api.github.com/repos/${SOURCE_REPO}/releases/latest")
              UPSTREAM_TAG=$(echo "$UPSTREAM_JSON" | jq -r '.tag_name // empty')
              
              # FIX: Use contains instead of endswith to match filenames like netclient-linux-amd64-v1.4.0
              ASSET_URL=$(echo "$UPSTREAM_JSON" | jq -r --arg pat "$ASSET_PATTERN" '(.assets // []) | .[] | select(.name | contains($pat)) | .browser_download_url' | head -n 1)
              
              if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" == "null" ]; then
                echo "Error: Asset matching '$ASSET_PATTERN' not found"; exit 1
              fi

              FILENAME=$(basename "$ASSET_URL")
              curl -L -s -o "/tmp/$FILENAME" "$ASSET_URL"
              UPSTREAM_HASH=$(sha256sum "/tmp/$FILENAME" | awk '{print $1}')

              LOCAL_HASH=""
              if gh release view "$TAG_LATEST" --repo "$REPO_FULL" >/dev/null 2>&1; then
                mkdir -p /tmp/local
                gh release download "$TAG_LATEST" --repo "$REPO_FULL" -p "$FILENAME" -D "/tmp/local" >/dev/null 2>&1 || true
                [ -f "/tmp/local/$FILENAME" ] && LOCAL_HASH=$(sha256sum "/tmp/local/$FILENAME" | awk '{print $1}')
              fi

              if [ "$LOCAL_HASH" == "$UPSTREAM_HASH" ]; then
                echo "NO NEW VERSION: Binary hashes match."; exit 0
              fi

              if [ -n "$LOCAL_HASH" ]; then
                gh release delete "$TAG_BACK" --repo "$REPO_FULL" --yes >/dev/null 2>&1 || true
                gh release create "$TAG_BACK" "/tmp/local/$FILENAME" --repo "$REPO_FULL" --title "$TAG_BACK" --notes "Prev stable"
              fi

              CLEAN_VERSION=$(echo "$UPSTREAM_TAG" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1)
              if [ -n "$CLEAN_VERSION" ]; then
                TARGET_TAG="${TAG_PREFIX}${CLEAN_VERSION}"
                gh release delete "$TARGET_TAG" --repo "$REPO_FULL" --yes >/dev/null 2>&1 || true
                gh release create "$TARGET_TAG" "/tmp/$FILENAME" --repo "$REPO_FULL" --title "$TARGET_TAG" --notes "Mirrored from $UPSTREAM_TAG"
              fi
              
              gh release delete "$TAG_LATEST" --repo "$REPO_FULL" --yes >/dev/null 2>&1 || true
              gh release create "$TAG_LATEST" "/tmp/$FILENAME" --repo "$REPO_FULL" --title "$TAG_LATEST" --notes "Tag: $UPSTREAM_TAG | SHA256: $UPSTREAM_HASH"

              ALL_TAGS=$(gh api "repos/$REPO_FULL/releases" --jq 'sort_by(.created_at) | reverse | .[].tag_name' | grep "^${TAG_PREFIX}" | grep -vE 'latest|back')
              COUNT=$(echo "$ALL_TAGS" | wc -l)
              if [ "$COUNT" -gt "$KEEP" ]; then
                TO_DELETE=$(echo "$ALL_TAGS" | tail -n +$((KEEP+1)))
                for T in $TO_DELETE; do
                  gh release delete "$T" --repo "$REPO_FULL" --yes
                done
              fi
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
