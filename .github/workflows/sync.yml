name: Mirror Container Images & Binaries

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Component name (e.g. nezha/nezha-agent)'
        required: true
        type: string

env:
  TARGET_NS: ghcr.io/${{ github.repository_owner }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq and yq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq grep
          wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load manifest
        id: manifest
        run: |
          MANIFEST="${{ github.event.inputs.component }}/manifest.yaml"
          if [ ! -f "$MANIFEST" ]; then
            echo "Manifest not found: $MANIFEST"
            exit 1
          fi

          TYPE=$(yq '.type' "$MANIFEST")
          SOURCE=$(yq '.source' "$MANIFEST")
          KEEP=$(yq '.keep_versions // 2' "$MANIFEST")
          SOURCE_REPO=$(yq '.source_repo // ""' "$MANIFEST")
          ASSET_PATTERN=$(yq '.asset_pattern // ""' "$MANIFEST")
          TARGET_PATH=$(yq '.target_path // "."' "$MANIFEST")
          TAG_PREFIX=$(yq '.tag_prefix // ""' "$MANIFEST")

          TARGET_OVERRIDE=$(yq '.target // ""' "$MANIFEST")
          if [ -n "$TARGET_OVERRIDE" ]; then
            TARGET="$TARGET_OVERRIDE"
          else
            if [[ "$SOURCE" == */* ]]; then
              IMAGE_NAME="${SOURCE#*/}"
            else
              IMAGE_NAME="$SOURCE"
            fi
            TARGET="${{ env.TARGET_NS }}/$IMAGE_NAME"
          fi

          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "source=$SOURCE" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "keep=$KEEP" >> $GITHUB_OUTPUT
          echo "source_repo=$SOURCE_REPO" >> $GITHUB_OUTPUT
          echo "asset_pattern=$ASSET_PATTERN" >> $GITHUB_OUTPUT
          echo "target_path=$TARGET_PATH" >> $GITHUB_OUTPUT
          echo "tag_prefix=$TAG_PREFIX" >> $GITHUB_OUTPUT

      - name: Sync by type
        run: |
          TYPE="${{ steps.manifest.outputs.type }}"
          SOURCE="${{ steps.manifest.outputs.source }}"
          TARGET="${{ steps.manifest.outputs.target }}"
          KEEP="${{ steps.manifest.outputs.keep }}"
          SOURCE_REPO="${{ steps.manifest.outputs.source_repo }}"
          ASSET_PATTERN="${{ steps.manifest.outputs.asset_pattern }}"
          TARGET_PATH="${{ steps.manifest.outputs.target_path }}"
          TAG_PREFIX="${{ steps.manifest.outputs.tag_prefix }}"

          mkdir -p "$TARGET_PATH"

          # --- COMMON VERSION DETERMINATION START ---
          
          if [ -z "$SOURCE_REPO" ]; then
            echo "Error: SOURCE_REPO must be specified for version tracking."
            exit 1
          fi
          
          # Filter for the highest numbered release that does NOT contain instability suffixes.
          STABLE_RELEASE_FILTER='
            .[] 
            | select(.prerelease == false) 
            | .tag_name 
            | select(
                (test("-(alpha|beta|rc|dev|test|snapshot)"; "i") | not) and
                (test("[0-9]+(\\.[0-9]+)+$"))
              ) // empty
            '
            
          # Get the highest STABLE version tag from GitHub Releases (Priority 1: ONLY GITHUB)
          UPSTREAM_TAG=$(curl -s "https://api.github.com/repos/${SOURCE_REPO}/releases" \
            | jq -r "$STABLE_RELEASE_FILTER" \
            | sort -Vr \
            | head -n 1)

          # CRITICAL CHECK: No Fallback to Docker Hub is allowed.
          if [ -z "$UPSTREAM_TAG" ]; then
            echo "Error: Could not find any stable release in GitHub Releases (${SOURCE_REPO}). Aborting."
            exit 1
          fi
          
          # Clean the tag: Extract SemVer pattern (X.Y.Z) explicitly.
          # Converts 'n8n@1.123.4' to '1.123.4' and 'v1.2.3' to '1.2.3'
          CLEAN_TAG=$(echo "$UPSTREAM_TAG" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1)

          if [ -n "$CLEAN_TAG" ]; then
            UPSTREAM_TAG="$CLEAN_TAG"
          else
            echo "Warning: Failed to extract version from '$UPSTREAM_TAG'. Using original."
          fi
          
          # --- COMMON VERSION DETERMINATION END ---

          case "$TYPE" in
            container)
              echo "Syncing container: $SOURCE â†’ $TARGET"

              SOURCE_IMAGE="$SOURCE:latest"
              TARGET_IMAGE="$TARGET"
              TARGET_TAG="$UPSTREAM_TAG"
              
              # 1. Pull the 'latest' image (assuming author updates latest to match UPSTREAM_TAG)
              if ! docker pull "$SOURCE_IMAGE"; then
                echo "Error: Failed to pull $SOURCE_IMAGE. Aborting container sync."
                exit 1
              fi

              LATEST_ID=$(docker inspect --format='{{.Id}}' "$SOURCE_IMAGE")
              echo "Upstream 'latest' Image ID: $LATEST_ID"
              echo "Targeting stable version tag: $TARGET_TAG"

              LOCAL_TAG_ID=""
              
              if docker pull "$TARGET_IMAGE:$TARGET_TAG" > /dev/null 2>&1; then
                LOCAL_TAG_ID=$(docker inspect --format='{{.Id}}' "$TARGET_IMAGE:$TARGET_TAG")
                docker rmi "$TARGET_IMAGE:$TARGET_TAG"
              fi

              if [ -n "$LOCAL_TAG_ID" ] && [ "$LOCAL_TAG_ID" == "$LATEST_ID" ]; then
                echo "NO NEW VERSION: Upstream version $TARGET_TAG already mirrored. Stopping."
                exit 0
              else
                echo "NEW VERSION DETECTED. Pushing $TARGET_TAG..."
                docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE:$TARGET_TAG"
                docker push "$TARGET_IMAGE:$TARGET_TAG"
              fi
              
              # 4. Ensure 'latest' always points to the newest published image ID
              echo "Ensuring 'latest' tag points to $LATEST_ID."
              docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE:latest"
              docker push "$TARGET_IMAGE:latest"

              # 5. Cleanup Logic (to remove old versions based on KEEP)
              
              ALL_VERSIONS_DATA=$(gh api -H "Accept: application/vnd.github+json" \
                "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions" \
                2>/dev/null)

              if [ -z "$ALL_VERSIONS_DATA" ]; then
                  echo "No versions found in registry for cleanup."
                  break
              fi

              # Extract all numeric/version tags (excluding 'latest') and sort them by version string, reverse
              ALL_TAGS=$(echo "$ALL_VERSIONS_DATA" \
                | jq -r '
                    map(select(.metadata.container.tags and (.metadata.container.tags | length > 0))) 
                    | sort_by(.created_at) 
                    | reverse 
                    | .[].metadata.container.tags[]?
                  ' \
                | grep -v '^$' | grep -v '^latest$' | sort -Vr)
              
              COUNT=$(echo "$ALL_TAGS" | wc -l)
              
              if [ "$COUNT" -gt "$KEEP" ]; then
                echo "Cleanup required: $COUNT version tags found, keeping $KEEP."
                TO_DELETE_TAGS=$(echo "$ALL_TAGS" | tail -n +$((KEEP+1)))
                
                while IFS= read -r TAG_DEL; do
                  if [ -z "$TAG_DEL" ]; then continue; fi
                  
                  # Find the unique ID associated with the specific tag
                  VERSION_ID=$(echo "$ALL_VERSIONS_DATA" \
                    | jq -r ".[] | select(.metadata.container.tags and (.metadata.container.tags | index(\"$TAG_DEL\"))) | .id")

                  if [ -n "$VERSION_ID" ]; then
                    echo "Deleting old version tag: $TAG_DEL (ID: $VERSION_ID)"
                    # Note: We can only delete the entire version ID, not just a tag.
                    gh api --method DELETE "/users/${{ github.actor }}/packages/container/${TARGET##*/}/versions/$VERSION_ID"
                  else
                      echo "Warning: Could not find Version ID for tag $TAG_DEL."
                  fi
                done <<< "$TO_DELETE_TAGS"
              fi
              ;;

          release-binary)
              echo "Syncing binary: $SOURCE_REPO"
              REPO_FULL="${{ github.repository }}"
              TAG_LATEST="${TAG_PREFIX}latest"

              # 1. Get latest release data via API
              UPSTREAM_JSON=$(curl -s -H "Authorization: token ${GH_TOKEN}" "https://api.github.com/repos/${SOURCE_REPO}/releases/latest")
              UPSTREAM_TAG=$(echo "$UPSTREAM_JSON" | jq -r '.tag_name')
              
              # Find asset URL by pattern
              ASSET_URL=$(echo "$UPSTREAM_JSON" | jq -r --arg pat "$ASSET_PATTERN" '.assets[] | select(.name | endswith($pat)) | .browser_download_url')
              
              if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" == "null" ]; then
                echo "Error: Asset not found"; exit 1
              fi

              # 2. Download upstream binary and calculate SHA256
              FILENAME=$(basename "$ASSET_URL")
              curl -L -s -o "/tmp/$FILENAME" "$ASSET_URL"
              UPSTREAM_HASH=$(sha256sum "/tmp/$FILENAME" | awk '{print $1}')
              echo "Upstream Hash: $UPSTREAM_HASH"

              # 3. Compare with local latest binary hash
              LOCAL_HASH=""
              if gh release view "$TAG_LATEST" --repo "$REPO_FULL" >/dev/null 2>&1; then
                mkdir -p /tmp/local
                gh release download "$TAG_LATEST" --repo "$REPO_FULL" -p "$FILENAME" -D "/tmp/local" >/dev/null 2>&1 || true
                [ -f "/tmp/local/$FILENAME" ] && LOCAL_HASH=$(sha256sum "/tmp/local/$FILENAME" | awk '{print $1}')
              fi

              if [ "$LOCAL_HASH" == "$UPSTREAM_HASH" ]; then
                echo "NO NEW VERSION: Hashes match."
                exit 0
              fi

              # 4. New version flow: Create versioned release and update latest
              echo "NEW VERSION DETECTED: $UPSTREAM_TAG"
              
              # Extract clean version for tagging
              VERSION=$(echo "$UPSTREAM_TAG" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1)
              [ -z "$VERSION" ] && VERSION="$UPSTREAM_TAG"
              TARGET_TAG="${TAG_PREFIX}${VERSION}"

              # Create versioned release
              gh release create "$TARGET_TAG" "/tmp/$FILENAME" --repo "$REPO_FULL" --title "$TARGET_TAG" --notes "Mirrored from $UPSTREAM_TAG" || true
              
              # Re-create latest tag
              gh release delete "$TAG_LATEST" --repo "$REPO_FULL" --yes >/dev/null 2>&1 || true
              gh release create "$TAG_LATEST" "/tmp/$FILENAME" --repo "$REPO_FULL" --title "$TAG_LATEST" --notes "Upstream Tag: $UPSTREAM_TAG | SHA256: $UPSTREAM_HASH"

              # 5. Cleanup: Keep only $KEEP number of old releases
              ALL_TAGS=$(gh api "repos/$REPO_FULL/releases" --jq '.[] | .tag_name' | grep "^${TAG_PREFIX}" | grep -v "latest" | sort -Vr)
              COUNT=$(echo "$ALL_TAGS" | wc -l)
              if [ "$COUNT" -gt "$KEEP" ]; then
                echo "Cleaning up old releases..."
                TO_DELETE=$(echo "$ALL_TAGS" | tail -n +$((KEEP+1)))
                for T in $TO_DELETE; do
                  gh release delete "$T" --repo "$REPO_FULL" --yes
                done
              fi
              ;;

            *)
              echo "Unknown type: $TYPE"
              exit 1
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
